@startuml
class Application


package "moteur"{
  Interface Jeu{
    + init(): void
    + etreFini(): boolean
    + ajouterObservateur(DessinJeu): void
    - notifierObservateurs(): void
  }
  class Clavier{
    + handle(KeyEvent): void
  }
  class ClavierNonInteractif{
    + handle(KeyEvent): void
  }
  class MoteurJeu{
    + start(Stage): void
  }
}
package "lancercalculs"{
  class LancerCalculsChemins{
    + main(): void
  }
  class LancerCalculsVision{
      + main(): void
  }
  class LancerCalculsDataset{
        + main(): void
  }
}
package "outil"{
    class ChargementCarte{
        + {static} charger(String): int[][]
    }
    class Outil{
      + {static} applatissement(double[][]): double[]
    }
}
package "simulation"{
  enum Deplacement{
    HAUT
    BAS
    GAUCHE
    DROITE
    DIAG_HAUT_GAUCHE
    DIAG_HAUT_DROITE
    DIAG_BAS_GAUCHE
    DIAG_BAS_DROITE
    AUCUN
  }
  enum Comportements{
    ARBREDETERMINISTE
    ARBREDETERMINISTEV
    ALEATOIRE
    ARBREALEATOIRE
    RESEAUARBREDETERMINISTE
    RESEAUARBREALEATOIRE
  }
  enum CaseEnum{
    MUR
    SOL
    SORTIE
    SPAWN_PRISONNIER
    SPAWN_GARDIEN
  }

  package "apprentissage"{
    class ApprentissageDeArbre{
        + main(): void
    }
  }
  package "comportement"{
    class ReseauDeNeurones{
        + ReseauDeNeurones(String, Simulation, Personnage)
        - neuralNetwork : NeuralNetwork
    }
    Interface Comportement{
        + prendreDecision(): Deplacement
    }
    class Aleatoire{
        - deplacementAleatoire(): Deplacement
    }
    class ArbreDecision{
        + direction(Position, Position): Deplacement
    }
    class ArbreDecisionGardien{
      + ArbreDecisionGardien(Simulation, Personnage)
    }
    class ArbreDecisionGardienAleatoire{
        + ArbreDecisionGardienAleatoire(Simulation, Personnage)
        - choixDeplacementAleatoire(double[][]): int[]
    }
    class ArbreDecisionPrisonnier{
          + ArbreDecisionPrisonnier(Simulation, Personnage)
          + oppose(Deplacement): Deplacement
    }
    class ArbreDecisionPrisonnier2{
          + ArbreDecisionPrisonnier(Simulation, Personnage)
          + fuir(): Deplacement
    }
  }
  class Simulation{
    - nbTours : int
    - estFini : boolean
    - victoirePrisonnier : boolean
    - victoireGardien : boolean
    - carteBayesiennes : HashMap<Personnage, double[][]>
    - bayesiens : HashMap<Personnage, Bayesien>
    + {static} final CARTE : int[][]
    + {static} final VISION : HashMap<Position, ArrayList<Position>>
    + {static} final CHEMINS : HashMap<List<Position>, Stack>
    + historiquePosition : HashMap<Personnage, List<Position>>
    + historiqueBayesien : HashMap<Personnage, List<double[][]>>
    + historiqueDeplacement : HashMap<Personnage, List<Deplacement>>
    + Simulation()
    + Simulation(boolean)
    + Simulation(boolean, Comportements)
    + Simulation(Comportement, Comportement)
    + positionnerAgentsSpawnAleatoire(): void
    + positionnerAleatoirement(): void
    + deplacerAgents(): void
    + deplacerPersonnage(Personnage, Deplacement): boolean
    + deplacementJoueur(Deplacement): void
    + verifierDeplacement(Personnage, Personnage): boolean
    + miseAJourFinJeu(): void
    + actualisationBayesienne(Personnage, Personnage): void
    + estVisible(Personnage, boolean): boolean
    + murPresent(int, int): boolean
    + getPrisonnier(): Personnage
    + getGardien(): Personnage
    + getJoueur(): Personnage
    + getPosSortie(): Position
    + getCarteBayesienne(Personnage): double[][]
    + getBayesiens(): HashMap<Personnage, Bayesien>
    + getVictoirePrisonnier(): boolean
    + getVictoireGardien(): boolean
  }

  class Case{
    - x: int
    - y: int
    - contenu: int
  }

  package "personnage"{
    class Bayesien{
      - carteBayesienne: double[][]
      - casesValides : List<Case>
      + Bayesien()
      + calculerProbaPresence(double[][], List<Integer[]>): double[][]
      + getCasesVoisineValide(int, int): List<Case>
      + getPlusGrandeProbas(): List<Case>
      + getCarteBayesienne(): double[][]
    }
    class Position{
     - x: int
     - y: int
     + Position(int, int)
     + setX(int): void
     + setY(int): void
     + getX(): int
     + getY(): int
     + deplacer(int, int): void
     + deplacer(Deplacement): void
     + casesAdjacentes(): ArrayList<Position>
    }

    class Personnage{
      + Personnage(int, int)
      + {abstract} deplacer(Position): void
      + getPosition(): Position
      + setPosition(Position): void
      + getVision(): ArrayList<Position>
    }
    class Agent{
      + Agent(int, int)

    }
    class Joueur{
      + Joueur(int, int)
    }
  }
}

package "calculs"{
  class CalculVision{
    + {static} recupererVision(): HashMap<Position,ArrayList<Position>>
    + {static} ecrireVision(): void
    + {static} calculerCarteVision(): HashMap
    + {static} calculerVision(int, int): ArrayList
    + {static} cleanVision(HashMap<Position, ArrayList<Position>>: void
    + {static} parcours(Position, Position, ArrayList<Position>, ArrayList<Position>): boolean
  }
  class CalculChemins{
    + {static} recupererChemin(): HashMap<List<Position>, Stack>
    + {static} ecrireChemins(): void
    + {static} calculerChemins(): HashMap<List<Position>,Stack>
    + {static} isValid(int, int, Position): boolean
    + {static} isUnblocked(int[][], int, int, Position): boolean
    + {static} isDestination(Position, Position): boolean
    + {static} calculateHValue(Position, Position): double
    + {static} tracePath(Cell[][], Position): Stack
    + {static} aStarSearch(int[][], int, int, Position, Position): Stack
  }
}

package "affichage" {
  Interface DessinJeu{
    + update(Jeu): void
  }
  class VueSimulation{
    # imageMur: Image
    # imageSol : Image
    # imageSortie : Image
    # imagePrisonnier : Image
    # imageGardien : Image
    # prisonnierView : ImageView
    # gardienView : ImageView
    # TAILLE_CELLULE : int
    + VueSimulation()
    # initLabyrinthe(): void
    # {abstract} setOpacityPersonnage(): void
    # {abstract} updatePositions(): void
    # setPositions(Position, ImageView): void
  }
  class FiltreBayesien{
    + {static} initFiltre(double[][], int): Rectangle[][]
    + {static} updateBayes(Rectangle[][], double[][])
  }

  class VuePrincipale{
    - iterationLabel: Label
    - filtreVision: Rectangle[][]
    - tour: int
    - caseBayesienneHisto : Rectangle[][]
    + VuePrincipale()
    - init(): void
    + update(Jeu): void=
    + updateIteration(): void
    + initFiltreVision(): void
    + setFiltreVision(): void
    + historique(): void
    + updateHistorique(): void

  }

  class VueBayesienne{
      - persoView: ImageView
      - imagePerso: Image
      - caseBayesienne: Rectangle[][]
      - tour: int
      + VueBayesienne(Simulation, Personnage)
      - init(): void
      # updatePositions(): void
      - updateBayes(): void
      + update(int): void
  }
  class VuePrincipaleNonInteractive{
    - iterationLabel : Label
    - tour : int
    - caseBayesienneHisto : Rectangle[][]
    + VuePrincipaleNonInteractive()
    - init(): void
    # updatePositions(): void
    + update(Jeu): void
    + updateIteration(): void
    + setPositions(Position, ImageView): void
  }
  class VueMenus{
    - {static} WIDTH : double
    - {static} HEIGHT : double
    # primaryStage: Stage
    - choixPersonnage : String
    + VueMenus(MoteurJeu)
    + VueMenus()
    - initPrimayStage(): void
    - setScene(Scene, String): void
    + afficherMenuPrincipal(): void
    + afficherMenuPersonnage(): void
    + afficherJeu(Jeu, Pane, Scene): void
    + afficherMenuIA(): void
    + getChoixPersonnage(): String
    + setChoixPersonnage(String): void
  }
  class VueMenusNonInteractive{
    - {static} WIDTH : double
    - {static} HEIGHT : double
    + VuePrincipaleNonInteractive(MoteurJeu)
    + afficherMenuIA(Stage): void
  }
}

package "main"{
  class Main{
    + main(): void
  }
}

Clavier "1" --> "1" Simulation : simulation
ClavierNonInteractif "1" --> "1" Simulation : simulation
Jeu <|.. Simulation
MoteurJeu --|> Application
MoteurJeu "1" --> "1" Jeu: jeu

ReseauDeNeurones "1" --> "1" Simulation : simulation
ReseauDeNeurones "1" --> "1" Personnage : personnage
ReseauDeNeurones ..|> Comportement
Aleatoire "1" --> "1" Simulation : simulation
Aleatoire "1" --> "1" Personnage : perso
Aleatoire ..|> Comportement
ArbreDecisionPrisonnier --|> ArbreDecision
ArbreDecisionGardien --|> ArbreDecision
ArbreDecisionPrisonnier ..|> Comportement
ArbreDecisionGardien ..|> Comportement
ArbreDecisionPrisonnier "1" --> "1" Simulation: simulation
ArbreDecisionPrisonnier "1" --> "1" Personnage: personnage
ArbreDecisionGardien "1" --> "1" Simulation: simulation
ArbreDecisionGardien "1" --> "1" Personnage: personnage
ArbreDecisionGardienAleatoire "1" --> "1" Simulation: simulation
ArbreDecisionGardienAleatoire "1" --> "1" Personnage: personnage
ArbreDecisionGardienAleatoire ..|> Comportement
ArbreDecisionGardienAleatoire --|> ArbreDecision
ArbreDecisionPrisonnier2 "1" --> "1" Simulation: simulation
ArbreDecisionPrisonnier2 "1" --> "1" Personnage: personnage
ArbreDecisionPrisonnier2 --|> ArbreDecision
ArbreDecisionPrisonnier2 ..|> Comportement



Bayesien "1" --> "*" Case: casesValides
Agent --|> Personnage
Joueur --|> Personnage
Personnage "1" --> "1" Position : position


Simulation "1" --> "*" DessinJeu : observateurs
Simulation "1" --> "1" Personnage: gardien
Simulation "1" --> "1" Personnage: prisonnier
Simulation "1" --> "1" Comportement: comportementGardien
Simulation "1" --> "1" Comportement: comportementPrisonnier

DessinJeu <|.. VuePrincipale
VuePrincipale --|> VueSimulation
VueBayesienne --|> VueSimulation
VuePrincipaleNonInteractive --|> VueSimulation
VuePrincipaleNonInteractive ..|> DessinJeu
VueBayesienne "1"-->"1" Simulation : simulation
VuePrincipale "1"-->"1" Simulation : simulation
VuePrincipaleNonInteractive "1"-->"1" Simulation : simulation
VuePrincipaleNonInteractive "1" --> "1" VueBayesienne: vB1
VuePrincipaleNonInteractive "1" --> "1" VueBayesienne: vB2
VueBayesienne "1"-->"1" Personnage : perso



@enduml