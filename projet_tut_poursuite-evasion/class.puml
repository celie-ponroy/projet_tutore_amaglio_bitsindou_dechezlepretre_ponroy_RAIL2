@startuml
class Application


package "moteur"{
  Interface Jeu{
    + init(): void
    + etreFini(): boolean
    + ajouterObservateur(DessinJeu): void
    - notifierObservateurs(): void
  }
  class Clavier{
    + handle(KeyEvent): void
  }
  class MoteurJeu{
    - {static} WIDTH : double
    - {static} HEIGHT : double
    + {static} launch(Jeu): void
    + {static} setTaille(double, double): void
    + start(Stage): void
  }
}
package "outil"{
    class Outil{
      + {static} sauve(String, Object): void
      + {static} applatissement(double[][]): double[]
      + {static} chargerRn(String): ReseauDeNeurones
    }
}
package "simulation"{
  enum Deplacement{
    HAUT
    BAS
    GAUCHE
    DROITE
    DIAG_HAUT_GAUCHE
    DIAG_HAUT_DROITE
    DIAG_BAS_GAUCHE
    DIAG_BAS_DROITE
    AUCUN
  }
  package "apprentissage"{
    class ApprentissageDeArbre{
        + main(): void
    }
  }
  package "comportement"{
    package reseau_neurones{
        class Neurone{
          + Value: double
          + Weights : double[]
          + Biais : double
          + Delta : double
          + Neurone()
        }
        class Couche{
          + Length : int
          + Couche(int, int)
        }
        Interface FonctionActivation{
           + evaluate(double): double
           + evaluateDer(double): double
        }
        class Sigmoide{}
        class ReseauDeNeurones{
          + vitesseApprentissage: double
          + ReseauDeNeurones(int[], double)
          + execute(double[]): double[]
          + retroPropagation(double[], double[]): double
        }
    }
    Interface Comportement{
        + prendreDecision(): Deplacement
        + prendreDecision(double[]): Deplacement
    }
    class ArbreDecision{
        + direction(Position, Position): Deplacement
    }
    class ArbreDecisionGardien{
      + ArbreDecisionGardien(Simulation, Personnage)
    }
    class ArbreDecisionPrisonnier{
          + ArbreDecisionPrisonnier(Simulation, Personnage)
          + oppose(Deplacement): Deplacement
    }
  }
  class Simulation{
    - nbTours : int
    - estFini : boolean
    + {static} final CARTE : int[][]
    + {static} final MUR : int
    + {static} final SORTIE : int
    + {static} final SOL : int
    + Simulation()
    + deplacementJoueur(Deplacement): void
    + murPresent(int, int): boolean
    + getPrisonnier(): Personnage
    + getGardien(): Personnage
  }

  class Case{
    - x: int
    - y: int
    - contenu: int
  }

  class CalculVision{
    + {static} recupererVision(): HashMap<Position,ArrayList<Position>>
    + {static} ecrireVision(): void
    + {static} calculerCarteVision(): HashMap
    + {static} calculerVision(int, int): ArrayList
  }
  package "personnage"{
    class Bayesien{
      - carteBayesienne: double[][]
      + Bayesien()
      + calculerProbaPresence(double[][], List<Integer[]>): double[][]
      + getCasesVoisineValide(int, int): List<Case>
      + getPlusGrandeProbas(): List<Case>
      + getCarteBayesienne(): double[][]
    }
    class Position{
     - x: int
     - y: int
     + Position(int, int)
     + setX(int): void
     + setY(int): void
     + getX(): int
     + getY(): int
     + deplacer(int, int): void
     + deplacer(Deplacement): void
    }

    class Personnage{
      + {abstract} deplacer(int, int): void
      + {abstract} deplacer(Position): void
      + getPosition(): Position
    }

    class Agent{
      + Agent(int, int)
    }
    class Joueur{
      + Joueur(int, int)
    }
  }
}


package "affichage" {
  Interface DessinJeu{
    + update(Jeu): void
  }
    
  class VuePrincipale{
    - imageMur: Image
    - imageSol: Image
    - imageSortie: Image
    - imagePrisonnier: Image
    - imageGardien: Image
    - prisonnierView: ImageView
    - gardienView: ImageView
    + initImages(): void
    + initLabyrinthe(): void
    - updatePositions(): void
  }

  class VueBayesienne{
      - imageMur: Image
      - imageSol: Image
      - imageSortie: Image
      - imagePrisonnier: Image
      - imageGardien: Image
      - prisonnierView: ImageView
      - gardienView: ImageView
      + initImages(): void
      + initLabyrinthe(): void
      - updatePositions(): void
      - updateBayes(): void
    }
}

package "main"{
  class Main{
    + main(): void
  }
}

Bayesien "1" --> "*" Case: casesValides
Agent --|> Personnage
Joueur --|> Personnage
Personnage "1" --> "1" Position : position
MoteurJeu --|> Application
MoteurJeu "1" --> "1" Jeu: jeu
Simulation "1" --> "*" DessinJeu : observateurs
DessinJeu <|.. VuePrincipale
DessinJeu <|.. VueBayesienne
Simulation "1" --> "1" Personnage: gardien
Simulation "1" --> "1" Personnage: prisonnier
Clavier "1" --> "1" Simulation : simulation
Jeu <|.. Simulation
Couche "1" --> "*" Neurone : neurones
Sigmoide ..|> FonctionActivation
ReseauDeNeurones ..|> Comportement
ReseauDeNeurones "1" --> "*" Couche: couches
ReseauDeNeurones "1" --> "1" FonctionActivation: fonctionActivation
ArbreDecisionPrisonnier --|> ArbreDecision
ArbreDecisionGardien --|> ArbreDecision
ArbreDecisionPrisonnier ..|> Comportement
ArbreDecisionGardien ..|> Comportement
ArbreDecisionPrisonnier "1" --> "1" Simulation: simulation
ArbreDecisionPrisonnier "1" --> "1" Personnage: personnage
ArbreDecisionGardien "1" --> "1" Simulation: simulation
ArbreDecisionGardien "1" --> "1" Personnage: personnage

@enduml